



<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="复制">
      
        <meta name="lang:clipboard.copied" content="已复制">
      
        <meta name="lang:search.language" content="ja">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="没有找到符合条件的结果">
      
        <meta name="lang:search.result.one" content="找到 1 个符合条件的结果">
      
        <meta name="lang:search.result.other" content="# 个符合条件的结果">
      
        <meta name="lang:search.tokenizer" content="[\uff0c\u3002]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.6.0">
    
    
      
        <title>7、ElasticSearch深度探秘搜索技术 - 学习笔记</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.1b62728e.css">
      
      
    
    
      <script src="../../assets/javascripts/modernizr.268332fc.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    <body dir="ltr">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#_1" tabindex="1" class="md-skip">
        跳转至
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="学习笔记" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              学习笔记
            </span>
            <span class="md-header-nav__topic">
              
                7、ElasticSearch深度探秘搜索技术
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="学习笔记" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    学习笔记
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="主页" class="md-nav__link">
      主页
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../Python/" title="Python" class="md-nav__link">
      Python
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../Java/" title="Java" class="md-nav__link">
      Java
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../php/" title="PHP" class="md-nav__link">
      PHP
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../" title="ElasticSearch" class="md-nav__link">
      ElasticSearch
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../JavaScript/" title="JavaScript" class="md-nav__link">
      JavaScript
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../MySQL/" title="MySQL" class="md-nav__link">
      MySQL
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../人工智能/" title="人工智能" class="md-nav__link">
      人工智能
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../LEK/" title="LEK" class="md-nav__link">
      LEK
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../设计模式/" title="设计模式" class="md-nav__link">
      设计模式
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../Linux/" title="Linux" class="md-nav__link">
      Linux
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../前端/" title="前端" class="md-nav__link">
      前端
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    手动控制全文检索结果的精准度
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#termboolmultiword" class="md-nav__link">
    基于term+bool实现的multiword搜索底层原理剖析
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boost" class="md-nav__link">
    基于boost的细粒度搜索条件权重控制
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shardrelevance-score" class="md-nav__link">
    多shard场景下relevance score不准确问题大揭秘
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dis_maxbest-fields" class="md-nav__link">
    基于dis_max实现best fields策略进行多字段搜索
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tie_breakerdis_max" class="md-nav__link">
    基于tie_breaker参数优化dis_max搜索效果
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#multi_matchdis_maxtie_breaker" class="md-nav__link">
    基于multi_match语法实现dis_max+tie_breaker
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#multi_matchmost-fielsmulti-field" class="md-nav__link">
    基于multi_match+most fiels策略进行multi-field搜索
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#most_fieldscross-fields-search" class="md-nav__link">
    使用most_fields策略进行cross-fields search弊端大揭秘
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#copy_tofieldcross-fields" class="md-nav__link">
    使用copy_to定制组合field解决cross-fields搜索弊端
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cross-fiels" class="md-nav__link">
    使用原生cross-fiels技术解决搜索弊端
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                  <h1>7、ElasticSearch深度探秘搜索技术</h1>
                
                <h2 id="_1">手动控制全文检索结果的精准度</h2>
<p>1、为帖子数据增加标题字段</p>
<div class="codehilite"><pre><span></span><span class="err">POST /forum/article/_bulk</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;1&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;title&quot; : &quot;this is java and elasticsearch blog&quot;} }</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;2&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;title&quot; : &quot;this is java blog&quot;} }</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;3&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;title&quot; : &quot;this is elasticsearch blog&quot;} }</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;4&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;title&quot; : &quot;this is java, elasticsearch, hadoop blog&quot;} }</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;5&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;title&quot; : &quot;this is spark blog&quot;} }</span>
</pre></div>


<p>2、搜索标题中包含java或elasticsearch的blog</p>
<p>这个，就跟之前的那个term query，不一样了。不是搜索exact value，是进行full text全文检索。<br />
match query，是负责进行全文检索的。<br />
当然，如果要检索的field，是not_analyzed类型的，那么match query也相当于term query。</p>
<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">    &quot;query&quot;: {</span>
<span class="err">        &quot;match&quot;: {</span>
<span class="err">            &quot;title&quot;: &quot;java elasticsearch&quot;</span>
<span class="err">        }</span>
<span class="err">    }</span>
<span class="err">}</span>
</pre></div>


<p>3、搜索标题中包含java和elasticsearch的blog</p>
<p>搜索结果精准控制的第一步：<br />
灵活使用and关键字，如果你是希望所有的搜索关键字都要匹配的，<br />
那么就用and，可以实现单纯match query无法实现的效果</p>
<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">  &quot;query&quot;: {</span>
<span class="err">      &quot;match&quot;: {</span>
<span class="err">          &quot;title&quot;: {</span>
<span class="err">            &quot;query&quot;: &quot;java elasticsearch&quot;,</span>
<span class="err">            &quot;operator&quot;: &quot;and&quot;</span>
<span class="err">          }</span>
<span class="err">      }</span>
<span class="err">  }</span>
<span class="err">}</span>
</pre></div>


<p>4、搜索包含java，elasticsearch，spark，hadoop，4个关键字中，至少3个的blog</p>
<p>控制搜索结果的精准度的第二步：<br />
指定一些关键字中，必须至少匹配其中的多少个关键字，才能作为结果返回</p>
<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">  &quot;query&quot;: {</span>
<span class="err">    &quot;match&quot;: {</span>
<span class="err">      &quot;title&quot;: {</span>
<span class="err">        &quot;query&quot;: &quot;java elasticsearch spark hadoop&quot;,</span>
<span class="err">        &quot;minimum_should_match&quot;: &quot;75%&quot;</span>
<span class="err">      }</span>
<span class="err">    }</span>
<span class="err">  }</span>
<span class="err">}</span>
</pre></div>


<p>5、用bool组合多个搜索条件，来搜索title</p>
<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">  &quot;query&quot;: {</span>
<span class="err">    &quot;bool&quot;: {</span>
<span class="err">      &quot;must&quot;:     { &quot;match&quot;: { &quot;title&quot;: &quot;java&quot; }},</span>
<span class="err">      &quot;must_not&quot;: { &quot;match&quot;: { &quot;title&quot;: &quot;spark&quot;  }},</span>
<span class="err">      &quot;should&quot;: [</span>
<span class="err">        { &quot;match&quot;: { &quot;title&quot;: &quot;hadoop&quot; }},</span>
<span class="err">        { &quot;match&quot;: { &quot;title&quot;: &quot;elasticsearch&quot;   }}</span>
<span class="err">      ]</span>
<span class="err">    }</span>
<span class="err">  }</span>
<span class="err">}</span>
</pre></div>


<p>6、bool组合多个搜索条件，如何计算relevance score</p>
<p>must和should搜索对应的分数，加起来，除以must和should的总数</p>
<p>排名第一：java，同时包含should中所有的关键字，hadoop，elasticsearch<br />
排名第二：java，同时包含should中的elasticsearch<br />
排名第三：java，不包含should中的任何关键字</p>
<p>should是可以影响相关度分数的</p>
<p>must是确保说，谁必须有这个关键字，同时会根据这个must的条件去计算出document对这个搜索条件的relevance score<br />
在满足must的基础之上，should中的条件，不匹配也可以，但是如果匹配的更多，<br />
那么document的relevance score就会更高</p>
<p>7、搜索java，hadoop，spark，elasticsearch，至少包含其中3个关键字</p>
<p>默认情况下，should是可以不匹配任何一个的，<br />
比如上面的搜索中，this is java blog，就不匹配任何一个should条件<br />
但是有个例外的情况，如果没有must的话，那么should中必须至少匹配一个才可以<br />
比如下面的搜索，should中有4个条件，默认情况下，只要满足其中一个条件，就可以匹配作为结果返回</p>
<p>但是可以精准控制，should的4个条件中，至少匹配几个才能作为结果返回</p>
<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">  &quot;query&quot;: {</span>
<span class="err">    &quot;bool&quot;: {</span>
<span class="err">      &quot;should&quot;: [</span>
<span class="err">        {&quot;match&quot;: { &quot;title&quot;: &quot;java&quot; }},</span>
<span class="err">        {&quot;match&quot;: { &quot;title&quot;: &quot;elasticsearch&quot;}},</span>
<span class="err">        {&quot;match&quot;: { &quot;title&quot;: &quot;hadoop&quot;}},</span>
<span class="err">        {&quot;match&quot;: { &quot;title&quot;: &quot;spark&quot;}}</span>
<span class="err">      ],</span>
<span class="err">      &quot;minimum_should_match&quot;: 3</span>
<span class="err">    }</span>
<span class="err">  }</span>
<span class="err">}</span>
</pre></div>


<p>梳理一下学到的知识点</p>
<p>1、全文检索的时候，进行多个值的检索，有两种做法，match query；should<br />
2、控制搜索结果精准度：and operator，minimum_should_match</p>
<h2 id="termboolmultiword">基于term+bool实现的multiword搜索底层原理剖析</h2>
<p>1、普通match如何转换为term+should</p>
<div class="codehilite"><pre><span></span><span class="err">{</span>
    <span class="ss">&quot;match&quot;</span><span class="p">:</span> <span class="err">{</span> <span class="ss">&quot;title&quot;</span><span class="p">:</span> <span class="ss">&quot;java elasticsearch&quot;</span><span class="err">}</span>
<span class="err">}</span>
</pre></div>


<p>使用诸如上面的match query进行多值搜索的时候，es会在底层自动将这个match query转换为bool的语法<br />
bool should，指定多个搜索词，同时使用term query</p>
<div class="codehilite"><pre><span></span><span class="err">{</span>
  <span class="ss">&quot;bool&quot;</span><span class="p">:</span> <span class="err">{</span>
    <span class="ss">&quot;should&quot;</span><span class="p">:</span> <span class="p">[</span>
      <span class="err">{</span> <span class="ss">&quot;term&quot;</span><span class="p">:</span> <span class="err">{</span> <span class="ss">&quot;title&quot;</span><span class="p">:</span> <span class="ss">&quot;java&quot;</span> <span class="err">}}</span><span class="p">,</span>
      <span class="err">{</span> <span class="ss">&quot;term&quot;</span><span class="p">:</span> <span class="err">{</span> <span class="ss">&quot;title&quot;</span><span class="p">:</span> <span class="ss">&quot;elasticsearch&quot;</span><span class="err">}}</span>
    <span class="p">]</span>
  <span class="err">}</span>
<span class="err">}</span>
</pre></div>


<p>2、and match如何转换为term+must</p>
<div class="codehilite"><pre><span></span><span class="err">{</span>
    <span class="ss">&quot;match&quot;</span><span class="p">:</span> <span class="err">{</span>
        <span class="ss">&quot;title&quot;</span><span class="p">:</span> <span class="err">{</span>
            <span class="ss">&quot;query&quot;</span><span class="p">:</span>    <span class="ss">&quot;java elasticsearch&quot;</span><span class="p">,</span>
            <span class="ss">&quot;operator&quot;</span><span class="p">:</span> <span class="ss">&quot;and&quot;</span>
        <span class="err">}</span>
    <span class="err">}</span>
<span class="err">}</span>

<span class="err">{</span>
  <span class="ss">&quot;bool&quot;</span><span class="p">:</span> <span class="err">{</span>
    <span class="ss">&quot;must&quot;</span><span class="p">:</span> <span class="p">[</span>
      <span class="err">{</span> <span class="ss">&quot;term&quot;</span><span class="p">:</span> <span class="err">{</span> <span class="ss">&quot;title&quot;</span><span class="p">:</span> <span class="ss">&quot;java&quot;</span> <span class="err">}}</span><span class="p">,</span>
      <span class="err">{</span> <span class="ss">&quot;term&quot;</span><span class="p">:</span> <span class="err">{</span> <span class="ss">&quot;title&quot;</span><span class="p">:</span> <span class="ss">&quot;elasticsearch&quot;</span>   <span class="err">}}</span>
    <span class="p">]</span>
  <span class="err">}</span>
<span class="err">}</span>
</pre></div>


<p>3、minimum_should_match如何转换</p>
<div class="codehilite"><pre><span></span><span class="err">{</span>
    <span class="ss">&quot;match&quot;</span><span class="p">:</span> <span class="err">{</span>
        <span class="ss">&quot;title&quot;</span><span class="p">:</span> <span class="err">{</span>
            <span class="ss">&quot;query&quot;</span><span class="p">:</span> <span class="ss">&quot;java elasticsearch hadoop spark&quot;</span><span class="p">,</span>
            <span class="ss">&quot;minimum_should_match&quot;</span><span class="p">:</span> <span class="ss">&quot;75%&quot;</span>
        <span class="err">}</span>
    <span class="err">}</span>
<span class="err">}</span>

<span class="err">{</span>
  <span class="ss">&quot;bool&quot;</span><span class="p">:</span> <span class="err">{</span>
    <span class="ss">&quot;should&quot;</span><span class="p">:</span> <span class="p">[</span>
      <span class="err">{</span> <span class="ss">&quot;term&quot;</span><span class="p">:</span> <span class="err">{</span> <span class="ss">&quot;title&quot;</span><span class="p">:</span> <span class="ss">&quot;java&quot;</span> <span class="err">}}</span><span class="p">,</span>
      <span class="err">{</span> <span class="ss">&quot;term&quot;</span><span class="p">:</span> <span class="err">{</span> <span class="ss">&quot;title&quot;</span><span class="p">:</span> <span class="ss">&quot;elasticsearch&quot;</span>   <span class="err">}}</span><span class="p">,</span>
      <span class="err">{</span> <span class="ss">&quot;term&quot;</span><span class="p">:</span> <span class="err">{</span> <span class="ss">&quot;title&quot;</span><span class="p">:</span> <span class="ss">&quot;hadoop&quot;</span> <span class="err">}}</span><span class="p">,</span>
      <span class="err">{</span> <span class="ss">&quot;term&quot;</span><span class="p">:</span> <span class="err">{</span> <span class="ss">&quot;title&quot;</span><span class="p">:</span> <span class="ss">&quot;spark&quot;</span> <span class="err">}}</span>
    <span class="p">],</span>
    <span class="ss">&quot;minimum_should_match&quot;</span><span class="p">:</span> <span class="mi">3</span> 
  <span class="err">}</span>
<span class="err">}</span>
</pre></div>


<p>转换过程：<br />
match query --&gt; bool + term</p>
<h2 id="boost">基于boost的细粒度搜索条件权重控制</h2>
<p>需求：<br />
搜索标题中包含java的帖子，<br />
同时呢，如果标题中包含hadoop或elasticsearch就优先搜索出来，<br />
同时呢，如果一个帖子包含java hadoop，<br />
一个帖子包含java elasticsearch，包含hadoop的帖子要比elasticsearch优先搜索出来</p>
<p>知识点，搜索条件的权重，boost，可以将某个搜索条件的权重加大，<br />
此时当匹配这个搜索条件和匹配另一个搜索条件的document，计算relevance score时，<br />
匹配权重更大的搜索条件的document，relevance score会更高，当然也就会优先被返回回来</p>
<p>默认情况下，搜索条件的权重都是一样的，都是1</p>
<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search </span>
<span class="err">{</span>
<span class="err">  &quot;query&quot;: {</span>
<span class="err">    &quot;bool&quot;: {</span>
<span class="err">      &quot;must&quot;: [</span>
<span class="err">        {</span>
<span class="err">          &quot;match&quot;: {</span>
<span class="err">            &quot;title&quot;: &quot;blog&quot;</span>
<span class="err">          }</span>
<span class="err">        }</span>
<span class="err">      ],</span>
<span class="err">      &quot;should&quot;: [</span>
<span class="err">        {</span>
<span class="err">          &quot;match&quot;: {</span>
<span class="err">            &quot;title&quot;: {</span>
<span class="err">              &quot;query&quot;: &quot;java&quot;</span>
<span class="err">            }</span>
<span class="err">          }</span>
<span class="err">        },</span>
<span class="err">        {</span>
<span class="err">          &quot;match&quot;: {</span>
<span class="err">            &quot;title&quot;: {</span>
<span class="err">              &quot;query&quot;: &quot;hadoop&quot;</span>
<span class="err">            }</span>
<span class="err">          }</span>
<span class="err">        },</span>
<span class="err">        {</span>
<span class="err">          &quot;match&quot;: {</span>
<span class="err">            &quot;title&quot;: {</span>
<span class="err">              &quot;query&quot;: &quot;elasticsearch&quot;</span>
<span class="err">            }</span>
<span class="err">          }</span>
<span class="err">        },</span>
<span class="err">        {</span>
<span class="err">          &quot;match&quot;: {</span>
<span class="err">            &quot;title&quot;: {</span>
<span class="err">              &quot;query&quot;: &quot;spark&quot;,</span>
<span class="err">              &quot;boost&quot;: 5</span>
<span class="err">            }</span>
<span class="err">          }</span>
<span class="err">        }</span>
<span class="err">      ]</span>
<span class="err">    }</span>
<span class="err">  }</span>
<span class="err">}</span>
</pre></div>


<h2 id="shardrelevance-score">多shard场景下relevance score不准确问题大揭秘</h2>
<p>1、多shard场景下relevance score不准确问题大揭秘</p>
<p>如果你的一个index有多个shard的话，可能搜索结果会不准确</p>
<p>2、如何解决该问题？</p>
<p>（1）生产环境下，数据量大，尽可能实现均匀分配</p>
<p>数据量很大的话，其实一般情况下，在概率学的背景下，es都是在多个shard中均匀路由数据的，<br />
路由的时候根据_id，负载均衡<br />
比如说有10个document，title都包含java，一共有5个shard，那么在概率学的背景下，<br />
如果负载均衡的话，其实每个shard都应该有2个doc，title包含java<br />
如果说数据分布均匀的话，其实就没有刚才说的那个问题了</p>
<p>（2）测试环境下，将索引的primary shard设置为1个，number_of_shards=1，index settings</p>
<p>如果说只有一个shard，那么当然，所有的document都在这个shard里面，就没有这个问题了</p>
<p>（3）测试环境下，搜索附带search_type=dfs_query_then_fetch参数，会将local IDF取出来计算global IDF</p>
<p>计算一个doc的相关度分数的时候，就会将所有shard对的local IDF计算一下，获取出来，<br />
在本地进行global IDF分数的计算，会将所有shard的doc作为上下文来进行计算，也能确保准确性。<br />
但是production生产环境下，不推荐这个参数，因为性能很差。</p>
<h2 id="dis_maxbest-fields">基于dis_max实现best fields策略进行多字段搜索</h2>
<p>1、为帖子数据增加content字段</p>
<div class="codehilite"><pre><span></span><span class="err">POST /forum/article/_bulk</span>
<span class="err">{ &quot;index&quot;: { &quot;_id&quot;: &quot;1&quot;} }</span>
<span class="err">{&quot;title&quot; : &quot;this is java and elasticsearch blog&quot;}</span>
<span class="err">{ &quot;index&quot;: { &quot;_id&quot;: &quot;2&quot;} }</span>
<span class="err">{&quot;title&quot; : &quot;this is java blog&quot;}</span>
<span class="err">{ &quot;index&quot;: { &quot;_id&quot;: &quot;3&quot;} }</span>
<span class="err">{&quot;title&quot; : &quot;this is elasticsearch blog&quot;}</span>
<span class="err">{ &quot;index&quot;: { &quot;_id&quot;: &quot;4&quot;} }</span>
<span class="err">{&quot;title&quot; : &quot;this is java, elasticsearch, hadoop blog&quot;}</span>
<span class="err">{ &quot;index&quot;: { &quot;_id&quot;: &quot;5&quot;} }</span>
<span class="err">{&quot;title&quot; : &quot;this is spark blog&quot;}</span>

<span class="err">POST /forum/article/_bulk</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;1&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;content&quot; : &quot;i like to write best elasticsearch article&quot;} }</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;2&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;content&quot; : &quot;i think java is the best programming language&quot;} }</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;3&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;content&quot; : &quot;i am only an elasticsearch beginner&quot;} }</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;4&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;content&quot; : &quot;elasticsearch and hadoop are all very good solution, i am a beginner&quot;} }</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;5&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;content&quot; : &quot;spark is best big data solution based on scala ,an programming language similar to java&quot;} }</span>
</pre></div>


<p>2、搜索title或content中包含java或solution的帖子</p>
<p>下面这个就是multi-field搜索，多字段搜索</p>
<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">    &quot;query&quot;: {</span>
<span class="err">        &quot;bool&quot;: {</span>
<span class="err">            &quot;should&quot;: [</span>
<span class="err">                { &quot;match&quot;: { &quot;title&quot;: &quot;java solution&quot; }},</span>
<span class="err">                { &quot;match&quot;: { &quot;content&quot;:  &quot;java solution&quot; }}</span>
<span class="err">            ]</span>
<span class="err">        }</span>
<span class="err">    }</span>
<span class="err">}</span>
</pre></div>


<p>3、结果分析</p>
<p>期望的是doc5，结果是doc2,doc4排在了前面</p>
<p>计算每个document的relevance score：每个query的分数，乘以matched query数量，除以总query数量</p>
<p>算一下doc4的分数</p>
<p>{ "match": { "title": "java solution" }}，针对doc4，是有一个分数的<br />
{ "match": { "content":  "java solution" }}，针对doc4，也是有一个分数的</p>
<p>所以是两个分数加起来，比如说，1.1 + 1.2 = 2.3<br />
matched query数量 = 2<br />
总query数量 = 2</p>
<p>2.3 * 2 / 2 = 2.3</p>
<p>算一下doc5的分数</p>
<p>{ "match": { "title": "java solution" }}，针对doc5，是没有分数的<br />
{ "match": { "content":  "java solution" }}，针对doc5，是有一个分数的</p>
<p>所以说，只有一个query是有分数的，比如2.3<br />
matched query数量 = 1<br />
总query数量 = 2</p>
<p>2.3 * 1 / 2 = 1.15</p>
<p>doc5的分数 = 1.15 &lt; doc4的分数 = 2.3</p>
<p>4、best fields策略，dis_max</p>
<p>best fields策略，就是说，搜索到的结果，应该是某一个field中匹配到了尽可能多的关键词，被排在前面；而不是尽可能多的field匹配到了少数的关键词，排在了前面</p>
<p>dis_max语法，直接取多个query中，分数最高的那一个query的分数即可</p>
<p>{ "match": { "title": "java solution" }}，针对doc4，是有一个分数的，1.1<br />
{ "match": { "content":  "java solution" }}，针对doc4，也是有一个分数的，1.2<br />
取最大分数，1.2</p>
<p>{ "match": { "title": "java solution" }}，针对doc5，是没有分数的<br />
{ "match": { "content":  "java solution" }}，针对doc5，是有一个分数的，2.3<br />
取最大分数，2.3</p>
<p>然后doc4的分数 = 1.2 &lt; doc5的分数 = 2.3，所以doc5就可以排在更前面的地方，符合我们的需要</p>
<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">  &quot;query&quot;: {</span>
<span class="err">    &quot;dis_max&quot;: {</span>
<span class="err">      &quot;queries&quot;: [</span>
<span class="err">        {&quot;match&quot;: {&quot;title&quot;: &quot;java solution&quot;}},</span>
<span class="err">        {&quot;match&quot;: {&quot;content&quot;: &quot;java solution&quot;}}</span>
<span class="err">      ]</span>
<span class="err">    }</span>
<span class="err">  }</span>
<span class="err">}</span>
</pre></div>


<h2 id="tie_breakerdis_max">基于tie_breaker参数优化dis_max搜索效果</h2>
<p>1、搜索title或content中包含java beginner的帖子</p>
<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">    &quot;query&quot;: {</span>
<span class="err">        &quot;dis_max&quot;: {</span>
<span class="err">            &quot;queries&quot;: [</span>
<span class="err">                { &quot;match&quot;: { &quot;title&quot;: &quot;java beginner&quot; }},</span>
<span class="err">                { &quot;match&quot;: { &quot;body&quot;:  &quot;java beginner&quot; }}</span>
<span class="err">            ]</span>
<span class="err">        }</span>
<span class="err">    }</span>
<span class="err">}</span>
</pre></div>


<p>有些场景不是太好复现的，因为是这样，你需要尝试去构造不同的文本，然后去构造一些搜索出来，去达到你要的一个效果</p>
<p>可能在实际场景中出现的一个情况是这样的：</p>
<p>（1）某个帖子，doc1，title中包含java，content不包含java beginner任何一个关键词<br />
（2）某个帖子，doc2，content中包含beginner，title中不包含任何一个关键词<br />
（3）某个帖子，doc3，title中包含java，content中包含beginner<br />
（4）最终搜索，可能出来的结果是，doc1和doc2排在doc3的前面，而不是我们期望的doc3排在最前面</p>
<p>dis_max，只是取分数最高的那个query的分数而已。</p>
<p>2、dis_max只取某一个query最大的分数，完全不考虑其他query的分数</p>
<p>3、使用tie_breaker将其他query的分数也考虑进去</p>
<p>tie_breaker参数的意义，在于说，将其他query的分数，乘以tie_breaker，然后综合与最高分数的那个query的分数，综合在一起进行计算<br />
除了取最高分以外，还会考虑其他的query的分数<br />
tie_breaker的值，在0~1之间，是个小数，就ok</p>
<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">    &quot;query&quot;: {</span>
<span class="err">        &quot;dis_max&quot;: {</span>
<span class="err">            &quot;queries&quot;: [</span>
<span class="err">                { &quot;match&quot;: { &quot;title&quot;: &quot;java beginner&quot; }},</span>
<span class="err">                { &quot;match&quot;: { &quot;body&quot;:  &quot;java beginner&quot; }}</span>
<span class="err">            ],</span>
<span class="err">            &quot;tie_breaker&quot;: 0.3</span>
<span class="err">        }</span>
<span class="err">    }</span>
<span class="err">}</span>
</pre></div>


<h2 id="multi_matchdis_maxtie_breaker">基于multi_match语法实现dis_max+tie_breaker</h2>
<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">  &quot;query&quot;: {</span>
<span class="err">    &quot;multi_match&quot;: {</span>
<span class="err">        &quot;query&quot;:                &quot;java solution&quot;,</span>
<span class="err">        &quot;type&quot;:                 &quot;best_fields&quot;, </span>
<span class="err">        &quot;fields&quot;:               [&quot;title^2&quot;, &quot;content&quot;],</span>
<span class="err">        &quot;tie_breaker&quot;:          0.3,</span>
<span class="err">        &quot;minimum_should_match&quot;: &quot;50%&quot; </span>
<span class="err">    }</span>
<span class="err">  } </span>
<span class="err">}</span>

<span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">  &quot;query&quot;: {</span>
<span class="err">    &quot;dis_max&quot;: {</span>
<span class="err">      &quot;queries&quot;:  [</span>
<span class="err">        {</span>
<span class="err">          &quot;match&quot;: {</span>
<span class="err">            &quot;title&quot;: {</span>
<span class="err">              &quot;query&quot;: &quot;java beginner&quot;,</span>
<span class="err">              &quot;minimum_should_match&quot;: &quot;50%&quot;,</span>
<span class="err">              &quot;boost&quot;: 2</span>
<span class="err">            }</span>
<span class="err">          }</span>
<span class="err">        },</span>
<span class="err">        {</span>
<span class="err">          &quot;match&quot;: {</span>
<span class="err">            &quot;body&quot;: {</span>
<span class="err">              &quot;query&quot;: &quot;java beginner&quot;,</span>
<span class="err">              &quot;minimum_should_match&quot;: &quot;30%&quot;</span>
<span class="err">            }</span>
<span class="err">          }</span>
<span class="err">        }</span>
<span class="err">      ],</span>
<span class="err">      &quot;tie_breaker&quot;: 0.3</span>
<span class="err">    }</span>
<span class="err">  } </span>
<span class="err">}</span>
</pre></div>


<p>minimum_should_match，主要是用来干嘛的？<br />
去长尾，long tail<br />
长尾，比如你搜索5个关键词，但是很多结果是只匹配1个关键词的，其实跟你想要的结果相差甚远，这些结果就是长尾<br />
minimum_should_match，控制搜索结果的精准度，只有匹配一定数量的关键词的数据，才能返回</p>
<h2 id="multi_matchmost-fielsmulti-field">基于multi_match+most fiels策略进行multi-field搜索</h2>
<p>从best-fields换成most-fields策略<br />
best-fields策略，主要是说将某一个field匹配尽可能多的关键词的doc优先返回回来<br />
most-fields策略，主要是说尽可能返回更多field匹配到某个关键词的doc，优先返回回来</p>
<div class="codehilite"><pre><span></span><span class="err">POST /forum/_mapping/article</span>
<span class="err">{</span>
<span class="err">  &quot;properties&quot;: {</span>
<span class="err">      &quot;sub_title&quot;: { </span>
<span class="err">          &quot;type&quot;:     &quot;string&quot;,</span>
<span class="err">          &quot;analyzer&quot;: &quot;english&quot;,</span>
<span class="err">          &quot;fields&quot;: {</span>
<span class="err">              &quot;std&quot;:   { </span>
<span class="err">                  &quot;type&quot;:     &quot;string&quot;,</span>
<span class="err">                  &quot;analyzer&quot;: &quot;standard&quot;</span>
<span class="err">              }</span>
<span class="err">          }</span>
<span class="err">      }</span>
<span class="err">  }</span>
<span class="err">}</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="err">POST /forum/article/_bulk</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;1&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;sub_title&quot; : &quot;learning more courses&quot;} }</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;2&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;sub_title&quot; : &quot;learned a lot of course&quot;} }</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;3&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;sub_title&quot; : &quot;we have a lot of fun&quot;} }</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;4&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;sub_title&quot; : &quot;both of them are good&quot;} }</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;5&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;sub_title&quot; : &quot;haha, hello world&quot;} }</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">  &quot;query&quot;: {</span>
<span class="err">    &quot;match&quot;: {</span>
<span class="err">      &quot;sub_title&quot;: &quot;learning courses&quot;</span>
<span class="err">    }</span>
<span class="err">  }</span>
<span class="err">}</span>
</pre></div>


<p>sub_title用的是enligsh analyzer，所以还原了单词</p>
<p>为什么，因为如果我们用的是类似于english analyzer这种分词器的话，就会将单词还原为其最基本的形态，stemmer<br />
learning --&gt; learn<br />
learned --&gt; learn<br />
courses --&gt; course</p>
<p>sub_titile: learning coureses --&gt; learn course</p>
<p>{ "doc" : {"sub_title" : "learned a lot of course"} }，<br />
就排在了{ "doc" : {"sub_title" : "learning more courses"} }的前面</p>
<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">   &quot;query&quot;: {</span>
<span class="err">        &quot;multi_match&quot;: {</span>
<span class="err">            &quot;query&quot;:  &quot;learning courses&quot;,</span>
<span class="err">            &quot;type&quot;:   &quot;most_fields&quot;, </span>
<span class="err">            &quot;fields&quot;: [ &quot;sub_title&quot;, &quot;sub_title.std&quot; ]</span>
<span class="err">        }</span>
<span class="err">    }</span>
<span class="err">}</span>
</pre></div>


<p>不只是TF/IDF算法。因为不同的query，不同的语法，都有不同的计算score的细节。</p>
<p>与best_fields的区别</p>
<p>（1）best_fields，是对多个field进行搜索，挑选某个field匹配度最高的那个分数，<br />
同时在多个query最高分相同的情况下，在一定程度上考虑其他query的分数。<br />
简单来说，你对多个field进行搜索，就想搜索到某一个field尽可能包含更多关键字的数据</p>
<p>优点：通过best_fields策略，以及综合考虑其他field，还有minimum_should_match支持，<br />
可以尽可能精准地将匹配的结果推送到最前面<br />
缺点：除了那些精准匹配的结果，其他差不多大的结果，排序结果不是太均匀，没有什么区分度了</p>
<p>实际的例子：百度之类的搜索引擎，最匹配的到最前面，但是其他的就没什么区分度了</p>
<p>（2）most_fields，综合多个field一起进行搜索，尽可能多地让所有field的query参与到总分数的计算中来，<br />
此时就会是个大杂烩，出现类似best_fields案例最开始的那个结果，结果不一定精准，<br />
某一个document的一个field包含更多的关键字，但是因为其他document有更多field匹配到了，<br />
所以排在了前面；所以需要建立类似sub_title.std这样的field，尽可能让某一个field精准匹配query string，<br />
贡献更高的分数，将更精准匹配的数据排到前面</p>
<p>优点：将尽可能匹配更多field的结果推送到最前面，整个排序结果是比较均匀的<br />
缺点：可能那些精准匹配的结果，无法推送到最前面</p>
<p>实际的例子：wiki，明显的most_fields策略，搜索结果比较均匀，但是的确要翻好几页才能找到最匹配的结果</p>
<h2 id="most_fieldscross-fields-search">使用most_fields策略进行cross-fields search弊端大揭秘</h2>
<p>cross-fields搜索，一个唯一标识，跨了多个field。比如一个人，标识，是姓名；<br />
一个建筑，它的标识是地址。姓名可以散落在多个field中，<br />
比如first_name和last_name中，地址可以散落在country，province，city中。</p>
<p>跨多个field搜索一个标识，比如搜索一个人名，或者一个地址，就是cross-fields搜索</p>
<p>初步来说，如果要实现，可能用most_fields比较合适。<br />
因为best_fields是优先搜索单个field最匹配的结果，cross-fields本身就不是一个field的问题了。</p>
<div class="codehilite"><pre><span></span><span class="err">POST /forum/article/_bulk</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;1&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;author_first_name&quot; : &quot;Peter&quot;, &quot;author_last_name&quot; : &quot;Smith&quot;} }</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;2&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;author_first_name&quot; : &quot;Smith&quot;, &quot;author_last_name&quot; : &quot;Williams&quot;} }</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;3&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;author_first_name&quot; : &quot;Jack&quot;, &quot;author_last_name&quot; : &quot;Ma&quot;} }</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;4&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;author_first_name&quot; : &quot;Robbin&quot;, &quot;author_last_name&quot; : &quot;Li&quot;} }</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;5&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;author_first_name&quot; : &quot;Tonny&quot;, &quot;author_last_name&quot; : &quot;Peter Smith&quot;} }</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">  &quot;query&quot;: {</span>
<span class="err">    &quot;multi_match&quot;: {</span>
<span class="err">      &quot;query&quot;:       &quot;Peter Smith&quot;,</span>
<span class="err">      &quot;type&quot;:        &quot;most_fields&quot;,</span>
<span class="err">      &quot;fields&quot;:      [ &quot;author_first_name&quot;, &quot;author_last_name&quot; ]</span>
<span class="err">    }</span>
<span class="err">  }</span>
<span class="err">}</span>
</pre></div>


<p>Peter Smith，匹配author_first_name，匹配到了Smith，这时候它的分数很高，为什么啊？？？<br />
因为IDF分数高，IDF分数要高，那么这个匹配到的term（Smith），在所有doc中的出现频率要低，author_first_name field中，Smith就出现过1次<br />
Peter Smith这个人，doc 1，Smith在author_last_name中，但是author_last_name出现了两次Smith，所以导致doc 1的IDF分数较低</p>
<p>问题1：只是找到尽可能多的field匹配的doc，而不是某个field完全匹配的doc</p>
<p>问题2：most_fields，没办法用minimum_should_match去掉长尾数据，就是匹配的特别少的结果</p>
<p>问题3：TF/IDF算法，比如Peter Smith和Smith Williams，搜索Peter Smith的时候，由于first_name中很少有Smith的，所以query在所有document中的频率很低，得到的分数很高，可能Smith Williams反而会排在Peter Smith前面</p>
<h2 id="copy_tofieldcross-fields">使用copy_to定制组合field解决cross-fields搜索弊端</h2>
<p>用most_fields策略，去实现cross-fields搜索，有3大弊端，而且搜索结果也显示出了这3大弊端</p>
<p>第一个办法：用copy_to，将多个field组合成一个field</p>
<p>问题其实就出在有多个field，有多个field以后，就很尴尬，我们只要想办法将一个标识跨在多个field的情况，<br />
合并成一个field即可。比如说，一个人名，本来是first_name，last_name，现在合并成一个full_name，不就ok了吗。。。。。</p>
<div class="codehilite"><pre><span></span><span class="err">PUT /forum/_mapping/article</span>
<span class="err">{</span>
<span class="err">  &quot;properties&quot;: {</span>
<span class="err">      &quot;new_author_first_name&quot;: {</span>
<span class="err">          &quot;type&quot;:     &quot;string&quot;,</span>
<span class="err">          &quot;copy_to&quot;:  &quot;new_author_full_name&quot; </span>
<span class="err">      },</span>
<span class="err">      &quot;new_author_last_name&quot;: {</span>
<span class="err">          &quot;type&quot;:     &quot;string&quot;,</span>
<span class="err">          &quot;copy_to&quot;:  &quot;new_author_full_name&quot; </span>
<span class="err">      },</span>
<span class="err">      &quot;new_author_full_name&quot;: {</span>
<span class="err">          &quot;type&quot;:     &quot;string&quot;</span>
<span class="err">      }</span>
<span class="err">  }</span>
<span class="err">}</span>
</pre></div>


<p>用了这个copy_to语法之后，就可以将多个字段的值拷贝到一个字段中，并建立倒排索引</p>
<div class="codehilite"><pre><span></span><span class="err">POST /forum/article/_bulk</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;1&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;new_author_first_name&quot; : &quot;Peter&quot;, &quot;new_author_last_name&quot; : &quot;Smith&quot;} }   --&gt; Peter Smith</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;2&quot;} } </span>
<span class="err">{ &quot;doc&quot; : {&quot;new_author_first_name&quot; : &quot;Smith&quot;, &quot;new_author_last_name&quot; : &quot;Williams&quot;} }    --&gt; Smith Williams</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;3&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;new_author_first_name&quot; : &quot;Jack&quot;, &quot;new_author_last_name&quot; : &quot;Ma&quot;} }     --&gt; Jack Ma</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;4&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;new_author_first_name&quot; : &quot;Robbin&quot;, &quot;new_author_last_name&quot; : &quot;Li&quot;} }     --&gt; Robbin Li</span>
<span class="err">{ &quot;update&quot;: { &quot;_id&quot;: &quot;5&quot;} }</span>
<span class="err">{ &quot;doc&quot; : {&quot;new_author_first_name&quot; : &quot;Tonny&quot;, &quot;new_author_last_name&quot; : &quot;Peter Smith&quot;} }   --&gt; Tonny Peter Smith</span>


<span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">  &quot;query&quot;: {</span>
<span class="err">    &quot;match&quot;: {</span>
<span class="err">      &quot;new_author_full_name&quot;: &quot;Peter Smith&quot;</span>
<span class="err">    }</span>
<span class="err">  }</span>
<span class="err">}</span>
</pre></div>


<p>比如官网也会给一些例子，说用什么什么文本，怎么怎么搜索，是怎么怎么样的效果。<br />
es版本在不断迭代，这个打分的算法也在不断的迭代。<br />
所以我们其实很难说，对类似这几讲讲解的best_fields，most_fields，cross_fields，完全复现出来应有的场景和效果。</p>
<p>更多的把原理和知识点给大家讲解清楚，带着大家演练一遍怎么操作的，做一下实验</p>
<p>期望的是说，比如大家自己在开发搜索应用的时候，碰到需要best_fields的场景，<br />
知道怎么做，知道best_fields的原理，可以达到什么效果；<br />
碰到most_fields的场景，知道怎么做，以及原理；<br />
碰到搜搜cross_fields标识的场景，知道怎么做，知道原理是什么，效果是什么。。。。</p>
<p>问题1：只是找到尽可能多的field匹配的doc，而不是某个field完全匹配的doc <br />
--&gt; 解决，最匹配的document被最先返回</p>
<p>问题2：most_fields，没办法用minimum_should_match去掉长尾数据，就是匹配的特别少的结果 <br />
--&gt; 解决，可以使用minimum_should_match去掉长尾数据</p>
<p>问题3：TF/IDF算法，比如Peter Smith和Smith Williams，<br />
搜索Peter Smith的时候，由于first_name中很少有Smith的，<br />
所以query在所有document中的频率很低，得到的分数很高，<br />
可能Smith Williams反而会排在Peter Smith前面 <br />
--&gt; 解决，Smith和Peter在一个field了，所以在所有document中出现的次数是均匀的，不会有极端的偏差</p>
<h2 id="cross-fiels">使用原生cross-fiels技术解决搜索弊端</h2>
<p>课程大纲</p>
<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">  &quot;query&quot;: {</span>
<span class="err">    &quot;multi_match&quot;: {</span>
<span class="err">      &quot;query&quot;: &quot;Peter Smith&quot;,</span>
<span class="err">      &quot;type&quot;: &quot;cross_fields&quot;, </span>
<span class="err">      &quot;operator&quot;: &quot;and&quot;,</span>
<span class="err">      &quot;fields&quot;: [&quot;author_first_name&quot;, &quot;author_last_name&quot;]</span>
<span class="err">    }</span>
<span class="err">  }</span>
<span class="err">}</span>
</pre></div>


<p>问题1：只是找到尽可能多的field匹配的doc，而不是某个field完全匹配的doc <br />
--&gt; 解决，要求每个term都必须在任何一个field中出现</p>
<p>Peter，Smith</p>
<p>要求Peter必须在author_first_name或author_last_name中出现<br />
要求Smith必须在author_first_name或author_last_name中出现</p>
<p>Peter Smith可能是横跨在多个field中的，所以必须要求每个term都在某个field中出现，<br />
组合起来才能组成我们想要的标识，完整的人名</p>
<p>原来most_fiels，可能像Smith Williams也可能会出现，<br />
因为most_fields要求只是任何一个field匹配了就可以，匹配的field越多，分数越高</p>
<p>问题2：most_fields，没办法用minimum_should_match去掉长尾数据，就是匹配的特别少的结果<br />
--&gt; 解决，既然每个term都要求出现，长尾肯定被去除掉了</p>
<p>java hadoop spark --&gt; 这3个term都必须在任何一个field出现了</p>
<p>比如有的document，只有一个field中包含一个java，那就被干掉了，作为长尾就没了</p>
<p>问题3：TF/IDF算法，比如Peter Smith和Smith Williams，<br />
搜索Peter Smith的时候，由于first_name中很少有Smith的，<br />
所以query在所有document中的频率很低，得到的分数很高，<br />
可能Smith Williams反而会排在Peter Smith前面 <br />
--&gt; 计算IDF的时候，将每个query在每个field中的IDF都取出来，取最小值，就不会出现极端情况下的极大值了</p>
<p>Peter Smith</p>
<p>Peter<br />
Smith</p>
<p>Smith，在author_first_name这个field中，在所有doc的这个Field中，出现的频率很低，导致IDF分数很高；<br />
Smith在所有doc的author_last_name field中的频率算出一个IDF分数，<br />
因为一般来说last_name中的Smith频率都较高，所以IDF分数是正常的，不会太高；<br />
然后对于Smith来说，会取两个IDF分数中，较小的那个分数。就不会出现IDF分过高的情况。</p>
                
                  
                
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            2019-2021
          </div>
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
  <div class="md-footer-social">
    <link rel="stylesheet" href="../../assets/fonts/font-awesome.css">
    
      <a href="https://github.com/mouday" class="md-footer-social__link fa fa-github"></a>
    
  </div>

    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.808e90bb.js"></script>
      
        
        
          
          <script src="../../assets/javascripts/lunr/lunr.stemmer.support.js"></script>
          
            
              
                <script src="../../assets/javascripts/lunr/tinyseg.js"></script>
              
              
                <script src="../../assets/javascripts/lunr/lunr.ja.js"></script>
              
            
          
          
        
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
    
  </body>
</html>