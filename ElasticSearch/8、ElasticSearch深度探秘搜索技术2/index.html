



<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="复制">
      
        <meta name="lang:clipboard.copied" content="已复制">
      
        <meta name="lang:search.language" content="ja">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="没有找到符合条件的结果">
      
        <meta name="lang:search.result.one" content="找到 1 个符合条件的结果">
      
        <meta name="lang:search.result.other" content="# 个符合条件的结果">
      
        <meta name="lang:search.tokenizer" content="[\uff0c\u3002]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.6.0">
    
    
      
        <title>8、ElasticSearch深度探秘搜索技术2 - 学习笔记</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.1b62728e.css">
      
      
    
    
      <script src="../../assets/javascripts/modernizr.268332fc.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    <body dir="ltr">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#phrase-matching" tabindex="1" class="md-skip">
        跳转至
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="学习笔记" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              学习笔记
            </span>
            <span class="md-header-nav__topic">
              
                8、ElasticSearch深度探秘搜索技术2
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="学习笔记" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    学习笔记
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="主页" class="md-nav__link">
      主页
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../Python/" title="Python" class="md-nav__link">
      Python
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../Java/" title="Java" class="md-nav__link">
      Java
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../php/" title="PHP" class="md-nav__link">
      PHP
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../" title="ElasticSearch" class="md-nav__link">
      ElasticSearch
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../JavaScript/" title="JavaScript" class="md-nav__link">
      JavaScript
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../MySQL/" title="MySQL" class="md-nav__link">
      MySQL
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../人工智能/" title="人工智能" class="md-nav__link">
      人工智能
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../LEK/" title="LEK" class="md-nav__link">
      LEK
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../设计模式/" title="设计模式" class="md-nav__link">
      设计模式
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../Linux/" title="Linux" class="md-nav__link">
      Linux
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#phrase-matching" class="md-nav__link">
    在案例实战中掌握phrase matching搜索技术
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#slop" class="md-nav__link">
    基于slop参数实现近似匹配以及原理剖析和相关实验
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#match" class="md-nav__link">
    混合使用match和近似匹配实现召回率与精准度的平衡
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rescoring" class="md-nav__link">
    使用rescoring机制优化近似匹配搜索的性能
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                  <h1>8、ElasticSearch深度探秘搜索技术2</h1>
                
                <h2 id="phrase-matching">在案例实战中掌握phrase matching搜索技术</h2>
<p>近似匹配</p>
<p>1、什么是近似匹配</p>
<p>两个句子</p>
<p>java is my favourite programming language, and I also think spark is a very good big data system.<br />
java spark are very related, because scala is spark's programming language and scala is also based on jvm like java.</p>
<p>match query，搜索java spark</p>
<p>{<br />
    "match": {<br />
        "content": "java spark"<br />
    }<br />
}</p>
<p>match query，只能搜索到包含java和spark的document，但是不知道java和spark是不是离的很近</p>
<p>包含java或包含spark，或包含java和spark的doc，都会被返回回来。我们其实并不知道哪个doc，java和spark距离的比较近。如果我们就是希望搜索java spark，中间不能插入任何其他的字符，那这个时候match去做全文检索，能搞定我们的需求吗？答案是，搞不定。</p>
<p>如果我们要尽量让java和spark离的很近的document优先返回，要给它一个更高的relevance score，这就涉及到了proximity match，近似匹配</p>
<p>如果说，要实现两个需求：</p>
<p>1、java spark，就靠在一起，中间不能插入任何其他字符，就要搜索出来这种doc<br />
2、java spark，但是要求，java和spark两个单词靠的越近，doc的分数越高，排名越靠前</p>
<p>要实现上述两个需求，用match做全文检索，是搞不定的，必须得用proximity match，近似匹配</p>
<p>phrase match，proximity match：短语匹配，近似匹配</p>
<p>这一讲，要学习的是phrase match，就是仅仅搜索出java和spark靠在一起的那些doc，比如有个doc，是java use'd spark，不行。必须是比如java spark are very good friends，是可以搜索出来的。</p>
<p>phrase match，就是要去将多个term作为一个短语，一起去搜索，只有包含这个短语的doc才会作为结果返回。不像是match，java spark，java的doc也会返回，spark的doc也会返回。</p>
<p>2、match_phrase</p>
<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">  &quot;query&quot;: {</span>
<span class="err">    &quot;match&quot;: {</span>
<span class="err">      &quot;content&quot;: &quot;java spark&quot;</span>
<span class="err">    }</span>
<span class="err">  }</span>
<span class="err">}</span>
</pre></div>


<p>单单包含java的doc也返回了，不是我们想要的结果</p>
<div class="codehilite"><pre><span></span><span class="err">POST /forum/article/5/_update</span>
<span class="err">{</span>
<span class="err">  &quot;doc&quot;: {</span>
<span class="err">    &quot;content&quot;: &quot;spark is best big data solution based on scala ,an programming language similar to java spark&quot;</span>
<span class="err">  }</span>
<span class="err">}</span>
</pre></div>


<p>将一个doc的content设置为恰巧包含java spark这个短语</p>
<p>match_phrase语法</p>
<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">    &quot;query&quot;: {</span>
<span class="err">        &quot;match_phrase&quot;: {</span>
<span class="err">            &quot;content&quot;: &quot;java spark&quot;</span>
<span class="err">        }</span>
<span class="err">    }</span>
<span class="err">}</span>
</pre></div>


<p>成功了，只有包含java spark这个短语的doc才返回了，只包含java的doc不会返回</p>
<p>3、term position</p>
<p>hello world, java spark     doc1<br />
hi, spark java              doc2</p>
<p>hello       doc1(0)   <br />
wolrd       doc1(1)<br />
java        doc1(2) doc2(2)<br />
spark       doc1(3) doc2(1)</p>
<p>了解什么是分词后的position</p>
<div class="codehilite"><pre><span></span><span class="k">GET</span> <span class="n">_analyze</span>
<span class="err">{</span>
  <span class="ss">&quot;text&quot;</span><span class="p">:</span> <span class="ss">&quot;hello world, java spark&quot;</span><span class="p">,</span>
  <span class="ss">&quot;analyzer&quot;</span><span class="p">:</span> <span class="ss">&quot;standard&quot;</span>
<span class="err">}</span>
</pre></div>


<p>4、match_phrase的基本原理</p>
<p>索引中的position，match_phrase</p>
<p>hello world, java spark     doc1<br />
hi, spark java              doc2</p>
<p>hello       doc1(0)   <br />
wolrd       doc1(1)<br />
java        doc1(2) doc2(2)<br />
spark       doc1(3) doc2(1)</p>
<p>java spark --&gt; match phrase</p>
<p>java spark --&gt; java和spark</p>
<p>java --&gt; doc1(2) doc2(2)<br />
spark --&gt; doc1(3) doc2(1)</p>
<p>要找到每个term都在的一个共有的那些doc，就是要求一个doc，必须包含每个term，才能拿出来继续计算</p>
<p>doc1 --&gt; java和spark --&gt; spark position恰巧比java大1 --&gt; java的position是2，spark的position是3，恰好满足条件</p>
<p>doc1符合条件</p>
<p>doc2 --&gt; java和spark --&gt; java position是2，spark position是1，spark position比java position小1，而不是大1 --&gt; 光是position就不满足，那么doc2不匹配</p>
<p>必须理解这块原理！！！！</p>
<p>因为后面的proximity match就是原理跟这个一模一样！！！</p>
<h2 id="slop">基于slop参数实现近似匹配以及原理剖析和相关实验</h2>
<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">    &quot;query&quot;: {</span>
<span class="err">        &quot;match_phrase&quot;: {</span>
<span class="err">            &quot;title&quot;: {</span>
<span class="err">                &quot;query&quot;: &quot;java spark&quot;,</span>
<span class="err">                &quot;slop&quot;:  1</span>
<span class="err">            }</span>
<span class="err">        }</span>
<span class="err">    }</span>
<span class="err">}</span>
</pre></div>


<p>slop的含义是什么？</p>
<p>query string，搜索文本，中的几个term，要经过几次移动才能与一个document匹配，这个移动的次数，就是slop</p>
<p>实际举例，一个query string经过几次移动之后可以匹配到一个document，然后设置slop</p>
<p>hello world, java is very good, spark is also very good.</p>
<p>java spark，match phrase，搜不到</p>
<p>如果我们指定了slop，那么就允许java spark进行移动，来尝试与doc进行匹配</p>
<div class="codehilite"><pre><span></span><span class="n">java</span>        <span class="k">is</span>      <span class="n">very</span>        <span class="n">good</span>        <span class="n">spark</span>       <span class="k">is</span>

<span class="n">java</span>        <span class="n">spark</span>
<span class="n">java</span>        <span class="c1">--&gt;     spark</span>
<span class="n">java</span>                <span class="c1">--&gt;         spark</span>
<span class="n">java</span>                            <span class="c1">--&gt;         spark</span>
</pre></div>


<p>这里的slop，就是3，因为java spark这个短语，spark移动了3次，就可以跟一个doc匹配上了</p>
<p>slop的含义，不仅仅是说一个query string terms移动几次，跟一个doc匹配上。一个query string terms，最多可以移动几次去尝试跟一个doc匹配上</p>
<p>slop，设置的是3，那么就ok</p>
<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">    &quot;query&quot;: {</span>
<span class="err">        &quot;match_phrase&quot;: {</span>
<span class="err">            &quot;title&quot;: {</span>
<span class="err">                &quot;query&quot;: &quot;java spark&quot;,</span>
<span class="err">                &quot;slop&quot;:  3</span>
<span class="err">            }</span>
<span class="err">        }</span>
<span class="err">    }</span>
<span class="err">}</span>
</pre></div>


<p>就可以把刚才那个doc匹配上，那个doc会作为结果返回</p>
<p>但是如果slop设置的是2，那么java spark，spark最多只能移动2次，此时跟doc是匹配不上的，那个doc是不会作为结果返回的</p>
<p>做实验，验证slop的含义</p>
<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">  &quot;query&quot;: {</span>
<span class="err">    &quot;match_phrase&quot;: {</span>
<span class="err">      &quot;content&quot;: {</span>
<span class="err">        &quot;query&quot;: &quot;spark data&quot;,</span>
<span class="err">        &quot;slop&quot;: 3</span>
<span class="err">      }</span>
<span class="err">    }</span>
<span class="err">  }</span>
<span class="err">}</span>

<span class="err">spark is best big data solution based on scala ,an programming language similar to java spark</span>

<span class="err">spark data</span>
<span class="err">      --&gt; data</span>
<span class="err">          --&gt; data</span>
<span class="err">spark         --&gt; data</span>

<span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">  &quot;query&quot;: {</span>
<span class="err">    &quot;match_phrase&quot;: {</span>
<span class="err">      &quot;content&quot;: {</span>
<span class="err">        &quot;query&quot;: &quot;data spark&quot;,</span>
<span class="err">        &quot;slop&quot;: 5</span>
<span class="err">      }</span>
<span class="err">    }</span>
<span class="err">  }</span>
<span class="err">}</span>

<span class="err">spark       is              best        big         data</span>

<span class="err">data        spark</span>
<span class="err">--&gt;         data/spark</span>
<span class="err">spark       &lt;--data</span>
<span class="err">spark       --&gt;             data</span>
<span class="err">spark                       --&gt;         data</span>
<span class="err">spark                                   --&gt;         data</span>
</pre></div>


<p>slop搜索下，关键词离的越近，relevance score就会越高，做实验说明。。。</p>
<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">  &quot;query&quot;: {</span>
<span class="err">    &quot;match_phrase&quot;: {</span>
<span class="err">      &quot;content&quot;: {</span>
<span class="err">        &quot;query&quot;: &quot;java best&quot;,</span>
<span class="err">        &quot;slop&quot;: 15</span>
<span class="err">      }</span>
<span class="err">    }</span>
<span class="err">  }</span>
<span class="err">}</span>
</pre></div>


<p>其实，加了slop的phrase match，就是proximity match，近似匹配</p>
<p>1、java spark，短语，doc，phrase match<br />
2、java spark，可以有一定的距离，但是靠的越近，越先搜索出来，proximity match</p>
<h2 id="match">混合使用match和近似匹配实现召回率与精准度的平衡</h2>
<p>召回率</p>
<p>比如你搜索一个java spark，总共有100个doc，能返回多少个doc作为结果，就是召回率，recall</p>
<p>精准度</p>
<p>比如你搜索一个java spark，能不能尽可能让包含java spark，或者是java和spark离的很近的doc，排在最前面，precision</p>
<p>直接用match_phrase短语搜索，会导致必须所有term都在doc field中出现，而且距离在slop限定范围内，才能匹配上</p>
<p>match phrase，proximity match，要求doc必须包含所有的term，才能作为结果返回；<br />
如果某一个doc可能就是有某个term没有包含，那么就无法作为结果返回</p>
<p>java spark --&gt; hello world java --&gt; 就不能返回了<br />
java spark --&gt; hello world, java spark --&gt; 才可以返回</p>
<p>近似匹配的时候，召回率比较低，精准度太高了</p>
<p>但是有时可能我们希望的是匹配到几个term中的部分，就可以作为结果出来，这样可以提高召回率。<br />
同时我们也希望用上match_phrase根据距离提升分数的功能，让几个term距离越近分数就越高，优先返回</p>
<p>就是优先满足召回率，意思，java spark，包含java的也返回，包含spark的也返回，包含java和spark的也返回；<br />
同时兼顾精准度，就是包含java和spark，同时java和spark离的越近的doc排在最前面</p>
<p>此时可以用bool组合match query和match_phrase query一起，来实现上述效果</p>
<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search</span>
<span class="err">{</span>
<span class="err">  &quot;query&quot;: {</span>
<span class="err">    &quot;bool&quot;: {</span>
<span class="err">      &quot;must&quot;: {</span>
<span class="err">        &quot;match&quot;: { </span>
<span class="err">          &quot;title&quot;: {</span>
<span class="err">            &quot;query&quot;:                &quot;java spark&quot; --&gt; java或spark或java spark，java和spark靠前，但是没法区分java和spark的距离，也许java和spark靠的很近，但是没法排在最前面</span>
<span class="err">          }</span>
<span class="err">        }</span>
<span class="err">      },</span>
<span class="err">      &quot;should&quot;: {</span>
<span class="err">        &quot;match_phrase&quot;: { --&gt; 在slop以内，如果java spark能匹配上一个doc，那么就会对doc贡献自己的relevance score，如果java和spark靠的越近，那么就分数越高</span>
<span class="err">          &quot;title&quot;: {</span>
<span class="err">            &quot;query&quot;: &quot;java spark&quot;,</span>
<span class="err">            &quot;slop&quot;:  50</span>
<span class="err">          }</span>
<span class="err">        }</span>
<span class="err">      }</span>
<span class="err">    }</span>
<span class="err">  }</span>
<span class="err">}</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="err">POST /forum/article/_bulk</span>
<span class="err">{&quot;index&quot;: {&quot;_id&quot;: 1}}</span>
<span class="err">{&quot;content&quot;: &quot;i think java is the best programming language&quot;}</span>
<span class="err">{&quot;index&quot;: {&quot;_id&quot;: 2}}</span>
<span class="err">{&quot;content&quot;: &quot;spark is best big data solution based on scala ,an programming language similar to java spark&quot;}</span>

<span class="err"># 召回率</span>
<span class="err">GET /forum/article/_search </span>
<span class="err">{</span>
<span class="err">  &quot;query&quot;: {</span>
<span class="err">    &quot;bool&quot;: {</span>
<span class="err">      &quot;must&quot;: [</span>
<span class="err">        {</span>
<span class="err">          &quot;match&quot;: {</span>
<span class="err">            &quot;content&quot;: &quot;java spark&quot;</span>
<span class="err">          }</span>
<span class="err">        }</span>
<span class="err">      ]</span>
<span class="err">    }</span>
<span class="err">  }</span>
<span class="err">}</span>


<span class="err"># 精准度，提升相关度分数relevance score</span>
<span class="err">GET /forum/article/_search </span>
<span class="err">{</span>
<span class="err">  &quot;query&quot;: {</span>
<span class="err">    &quot;bool&quot;: {</span>
<span class="err">      &quot;must&quot;: [</span>
<span class="err">        {</span>
<span class="err">          &quot;match&quot;: {</span>
<span class="err">            &quot;content&quot;: &quot;java spark&quot;</span>
<span class="err">          }</span>
<span class="err">        }</span>
<span class="err">      ],</span>
<span class="err">      &quot;should&quot;: [</span>
<span class="err">        {</span>
<span class="err">          &quot;match_phrase&quot;: {</span>
<span class="err">            &quot;content&quot;: {</span>
<span class="err">              &quot;query&quot;: &quot;java spark&quot;,</span>
<span class="err">              &quot;slop&quot;: 50</span>
<span class="err">            }</span>
<span class="err">          }</span>
<span class="err">        }</span>
<span class="err">      ]</span>
<span class="err">    }</span>
<span class="err">  }</span>
<span class="err">}</span>
</pre></div>


<h2 id="rescoring">使用rescoring机制优化近似匹配搜索的性能</h2>
<p>match和phrase match(proximity match)区别</p>
<p>match --&gt; 只要简单的匹配到了一个term，就可以理解将term对应的doc作为结果返回，扫描倒排索引，扫描到了就ok</p>
<p>phrase match --&gt; 首先扫描到所有term的doc list; 找到包含所有term的doc list; <br />
然后对每个doc都计算每个term的position，是否符合指定的范围; <br />
slop，需要进行复杂的运算，来判断能否通过slop移动，匹配一个doc</p>
<p>match query的性能比phrase match和proximity match（有slop）要高很多。<br />
因为后两者都要计算position的距离。<br />
match query比phrase match的性能要高10倍，比proximity match的性能要高20倍。</p>
<p>但是别太担心，因为es的性能一般都在毫秒级别，match query一般就在几毫秒，或者几十毫秒，<br />
而phrase match和proximity match的性能在几十毫秒到几百毫秒之间，所以也是可以接受的。</p>
<p>优化proximity match的性能，一般就是减少要进行proximity match搜索的document数量。<br />
主要思路就是，用match query先过滤出需要的数据，然后再用proximity match来根据term距离提高doc的分数，<br />
同时proximity match只针对每个shard的分数排名前n个doc起作用，来重新调整它们的分数，<br />
这个过程称之为rescoring，重计分。<br />
因为一般用户会分页查询，只会看到前几页的数据，所以不需要对所有结果进行proximity match操作。</p>
<p>用我们刚才的说法，match + proximity match同时实现召回率和精准度</p>
<p>默认情况下，match也许匹配了1000个doc，proximity match全都需要对每个doc进行一遍运算，<br />
判断能否slop移动匹配上，然后去贡献自己的分数<br />
但是很多情况下，match出来也许1000个doc，其实用户大部分情况下是分页查询的，<br />
所以可能最多只会看前几页，比如一页是10条，最多也许就看5页，就是50条<br />
proximity match只要对前50个doc进行slop移动去匹配，去贡献自己的分数即可，<br />
不需要对全部1000个doc都去进行计算和贡献分数</p>
<p>rescore：重打分</p>
<p>match：1000个doc，其实这时候每个doc都有一个分数了; <br />
proximity match，前50个doc，进行rescore，重打分，即可; 让前50个doc，term举例越近的，排在越前面</p>
<div class="codehilite"><pre><span></span><span class="err">GET /forum/article/_search </span>
<span class="err">{</span>
<span class="err">  &quot;query&quot;: {</span>
<span class="err">    &quot;match&quot;: {</span>
<span class="err">      &quot;content&quot;: &quot;java spark&quot;</span>
<span class="err">    }</span>
<span class="err">  },</span>
<span class="err">  &quot;rescore&quot;: {</span>
<span class="err">    &quot;window_size&quot;: 50,</span>
<span class="err">    &quot;query&quot;: {</span>
<span class="err">      &quot;rescore_query&quot;: {</span>
<span class="err">        &quot;match_phrase&quot;: {</span>
<span class="err">          &quot;content&quot;: {</span>
<span class="err">            &quot;query&quot;: &quot;java spark&quot;,</span>
<span class="err">            &quot;slop&quot;: 50</span>
<span class="err">          }</span>
<span class="err">        }</span>
<span class="err">      }</span>
<span class="err">    }</span>
<span class="err">  }</span>
<span class="err">}</span>
</pre></div>
                
                  
                
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            2019-2020
          </div>
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
  <div class="md-footer-social">
    <link rel="stylesheet" href="../../assets/fonts/font-awesome.css">
    
      <a href="https://github.com/mouday" class="md-footer-social__link fa fa-github"></a>
    
  </div>

    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.808e90bb.js"></script>
      
        
        
          
          <script src="../../assets/javascripts/lunr/lunr.stemmer.support.js"></script>
          
            
              
                <script src="../../assets/javascripts/lunr/tinyseg.js"></script>
              
              
                <script src="../../assets/javascripts/lunr/lunr.ja.js"></script>
              
            
          
          
        
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
    
  </body>
</html>